仕様書：コピー（cc）でAIに送信する翻訳・文章変換アプリ（API版 / ローカル切替設計込み）

⸻

0. 文書情報
	•	文書名：ccでAIに送る翻訳・文章変換アプリ 仕様書（Phase 1：API版）
	•	バージョン：0.1
	•	対象プラットフォーム（想定）：デスクトップ（macOS / Windows）
	•	理由：グローバルホットキー・クリップボード監視・常駐UIが実装しやすい
	•	開発フェーズ定義
	•	Phase 1：API経由（クラウドAI）で動く最小〜実用版
	•	Phase 2：ローカルAI（オンデバイス）への切替を設定で追加（設計はPhase 1から織り込む）

⸻

1. コンセプト / 目的

1.1 コンセプト

翻訳アプリ（DeepL系）の体験をベースにしつつ、翻訳だけでなく 文脈理解・意図保持・口調調整・要約・整形 まで“AIが実行する”アプリ。
操作は極限まで短くし、コピー操作（cc）だけで送信できる。

1.2 目的（達成したいこと）
	•	選択テキストを cc（コピー2回） で即AIに送れる
	•	翻訳結果を 最短1クリック（または自動） で貼り付けられる
	•	翻訳以外に「言い換え」「丁寧語化」「要約」「箇条書き化」などを同じ操作感で実行できる
	•	セキュリティ的に「何を送るか」「保存するか」を明確に制御できる
	•	将来ローカルAIに切り替え可能な内部設計にする（APIと同じI/Fで差し替え）

1.3 非目的（Phase 1ではやらない / 将来対応を含む）
	•	PDFのOCR（別機能として分離）
	•	画像入力、音声入力（後回し）
	•	チーム共有・共同編集（後回し）
	•	DB（データベース）から文章を生成する「仕様書作成を裏で進める機能」
	•	将来的に、DBに蓄積された要件・メモ・差分履歴などを参照して、裏で仕様書本文のドラフトを継続的に生成/更新する機能を追加検討する（Phase 1では非対応）

その文章の要約（上の太字項目の要約）
将来、DBの情報を材料にして仕様書ドラフトを自動生成・自動更新する機能を検討するが、Phase 1では実装しない。

⸻

2. 想定ユーザー / 利用シーン

2.1 想定ユーザー
	•	仕事で英日/日英のやり取りが多い人
	•	文章を整える必要がある人（メール、仕様書、チャット返信）
	•	翻訳アプリを開く手間を避け、ショートカットで完結させたい人

2.2 代表的な利用シーン
	•	ブラウザで英文を選択 → cc → 日本語訳が出て、そのまま貼り付け
	•	日本語メモ → cc → 英語メール文に整えて出力
	•	Slack/Teamsの文面 → cc → 丁寧で角が立たない表現に修正
	•	長文 → cc → 要点3行 + 箇条書きに整形

⸻

3. 用語定義
	•	cc：コピー操作を短時間に2回行う入力（デフォルト）
	•	macOS：⌘C を 0.5秒以内に2回
	•	Windows：Ctrl+C を 0.5秒以内に2回
	•	入力テキスト：クリップボードから取得した送信対象
	•	モード：翻訳/要約/言い換え等の処理種別
	•	プロバイダ：AIの実行元（Phase 1はAPI、Phase 2でローカル追加）

⸻

4. 体験設計（UX）

4.1 基本フロー（最重要）
	1.	ユーザーが任意アプリでテキスト選択
	2.	⌘C（Ctrl+C）を2回（cc）
	3.	アプリがクリップボード文字列を取得
	4.	送信前に「モード」と「入出力言語」を自動推定（必要なら固定設定も可能）
	5.	APIへ送信
	6.	結果を「フローティング小窓」または「メニューバー/トレイ」から表示
	7.	出力は以下のいずれかで完了
	•	A: 自動でクリップボードに格納（デフォルト推奨）
	•	B: ワンクリックでコピー
	•	C: ワンクリックで元アプリに貼り付け（疑似入力）

4.2 UIの形（常駐）
	•	macOS：メニューバー常駐 + 必要時だけポップオーバー
	•	Windows：トレイ常駐 + 必要時だけポップアップ

4.3 出力表示の要件
	•	出力テキストは読みやすい等幅/通常フォント切替（設定）
	•	長文は折り返し + スクロール
	•	2ペイン表示（入力/出力）を基本
	•	「再生成」「スタイル変更」「用語集適用」をUIから即実行可能

⸻

5. 機能要件（Phase 1：API）

5.1 入力取得
	•	ccトリガー検出（グローバル）
	•	デフォルト：0.5秒以内のコピー2回
	•	設定で変更：
	•	0.3〜1.0秒の範囲
	•	3回コピーで発火（誤爆対策）
	•	別ホットキー（例：⌥⌘A / Ctrl+Alt+A）も追加可能にする
	•	クリップボード文字列取得
	•	取得直後に最小バリデーション
	•	空文字は無視
	•	サイズ上限（例：50,000文字）を超えたら警告し、要約モード提案
	•	バイナリ/画像はPhase 1では非対応

5.2 モード（処理種別）

最低限のプリセットを同梱し、ユーザーが追加・編集できる設計。
	•	翻訳：自動言語判定 → 反対言語へ
	•	例：英→日 / 日→英（設定で固定可）
	•	ていねい化：カジュアル→ビジネス丁寧
	•	口調変換：フラット / 柔らかい / 断定を避ける / 箇条書き
	•	要約：3行要約 + 箇条書き（テンプレ）
	•	校正：誤字脱字・読みやすさ改善（意味を変えない）
	•	コード/技術文：用語維持、コードブロック保持（勝手な改変を抑制）

5.3 自動推定（制御前提）
	•	入力言語推定（軽量判定）
	•	出力言語決定ルール
	•	Auto：日本語が多い→英語へ、英語が多い→日本語へ
	•	固定：常に英→日、常に日→英
	•	モード自動推定（任意、デフォルトOFF推奨）
	•	誤判定の害が大きいので、基本はユーザーが選ぶ設計

5.4 結果の取り扱い
	•	出力を自動でクリップボードへ保存（ON/OFF）
	•	「自動貼り付け」機能（ON/OFF、危険度高）
	•	OSのアクセシビリティ権限が必要
	•	誤爆の可能性があるため、初期はOFF推奨
	•	「差分表示」
	•	校正/言い換えモードのとき、変更点が分かる表示（簡易で可）

5.5 履歴
	•	履歴ON/OFF（デフォルトOFF推奨）
	•	履歴を保存する場合
	•	保存内容：入力/出力/モード/日時/アプリ名（可能なら）
	•	暗号化保存（OSキーチェーン/DPAPI + ローカル暗号化）
	•	“この入力は保存しない”のワンショット指定

5.6 用語集
	•	用語集（Glossary）
	•	形式：source_term -> target_term
	•	優先適用（固有名詞・製品名・社内用語）
	•	モードごとに用語集の適用ON/OFF

⸻

6. 設定要件（Phase 1で実装する範囲）

6.1 AI実行方式（将来切替前提の設計）
	•	「AIエンジン」設定項目
	•	Phase 1：API（クラウド） のみ有効
	•	UI上は API / ローカル の2択を見せてもよいが、ローカルは「準備中」で無効化
	•	内部は Providerインターフェースで差し替え可能にする

6.2 API設定
	•	APIプロバイダ選択（将来対応）
	•	初期実装：OpenAI互換（OpenAI / Azure OpenAI等を想定）
	•	APIキー入力（OSの安全な保管領域へ）
	•	モデル選択（文字中心の軽量/高品質の選択肢）
	•	料金ガード
	•	1回あたりの最大トークン上限
	•	1日あたりの上限（ソフト制限で警告）
	•	プロキシ設定（企業環境向け、任意）

6.3 ショートカット
	•	cc検出の猶予時間
	•	代替ホットキー
	•	3回コピー発火など誤爆対策オプション

6.4 出力ルール
	•	自動コピー ON/OFF
	•	自動貼り付け ON/OFF
	•	改行保持 / 余計な説明文を出さない（規定プロンプトで制御）
	•	返答形式：
	•	「本文のみ」
	•	「本文 + 補足（別枠）」
	•	「原文/訳文の2段」など

6.5 プライバシー/安全
	•	“特定アプリでは動かさない”除外リスト
	•	“特定文字列が含まれると送らない”ルール（正規表現）
	•	例：password=, api_key, -----BEGIN
	•	ログの有無（デフォルト最小）

⸻

7. 非機能要件

7.1 性能
	•	体感目標：ccから結果表示まで平均2〜4秒（ネットワーク依存）
	•	失敗時：10秒程度でタイムアウトし、再試行UIを出す

7.2 信頼性
	•	ネットワーク断でもアプリは落ちない
	•	APIエラーはユーザーに意味のある文言で提示（後述）

7.3 セキュリティ
	•	APIキーは平文保存しない
	•	履歴保存時は暗号化
	•	送信前の危険検知（除外/パターン一致）はローカルで実行

7.4 透明性
	•	「送った内容」「適用モード」「送信先（API）」をUIで確認可能
	•	送信先がAPIであることを明確に表示（ローカルと混同させない）

⸻

8. API設計（アプリ内部I/F）

8.1 Providerインターフェース（差し替え前提）
	•	generate(inputText, modeId, settings) -> outputText
	•	estimate(inputText) -> {language, suggestedMode}（任意）
	•	healthCheck()

Phase 1：ApiProvider を実装
Phase 2：LocalProvider を追加し、同I/Fで置き換える

8.2 リクエスト構造（概念）
	•	system：安全ルール・出力制約（前置き禁止、訳だけ返す等）
	•	developer：モードテンプレ（翻訳、要約…）
	•	user：入力テキスト

8.3 プロンプト方針（暴走を抑える）
	•	余計な説明を加えない
	•	固有名詞・数値・単位は保持
	•	原文にない情報を足さない
	•	箇条書き指定時だけ箇条書き
※この4点はsystem側に固定で置く想定

⸻

9. 画面仕様（最低限）

9.1 メイン（ポップオーバー）

表示項目：
	•	入力欄（読み取り専用/編集可切替）
	•	モード選択ドロップダウン
	•	入力言語 / 出力言語（Auto/固定）
	•	出力欄
	•	操作ボタン：
	•	[再生成] [コピー] [貼り付け] [履歴に保存] [設定]

9.2 設定画面（タブ）
	•	一般：自動起動、UI位置、通知
	•	ショートカット：cc猶予、代替キー
	•	AI：プロバイダ、APIキー、モデル、上限
	•	出力：自動コピー、自動貼り付け、形式
	•	プライバシー：除外アプリ、パターン、履歴
	•	用語集：一覧、インポート/エクスポート（CSV）

9.3 通知
	•	成功：出力をクリップボードへ保存したことをトースト表示
	•	失敗：理由 + 再試行導線

⸻

10. エラーハンドリング仕様
	•	401/403（認証）：APIキー不備 → 「キーを確認してください」
	•	429（レート制限）：時間を置く / 上限設定の見直し
	•	5xx：プロバイダ障害 → 再試行導線
	•	タイムアウト：ネットワーク/混雑 → 再試行
	•	入力が長すぎ：要約モード提案（Phase 1は提案まで）
	•	禁止パターン一致：送信中止 + 検知理由表示（ローカル判定）

⸻

11. ログ / 計測（最小）
	•	送信回数、成功/失敗回数（端末内のみ）
	•	送信テキストはログに残さない（デフォルト）
	•	デバッグモードでのみ詳細ログ（ユーザーが明示ON）

⸻

12. リリース要件（受け入れ基準）
	•	ccで発火し、直近クリップボードのテキストを送れる
	•	翻訳（Auto言語）で実用的な結果が返る
	•	出力がワンクリックでコピーできる（自動コピーONなら即貼れる）
	•	APIキーが安全に保存される
	•	エラー時に原因が分かり、再試行できる
	•	除外アプリ設定が効く

⸻

13. 批判的観点（最初に潰すべき地雷）
	•	ccは誤爆しやすい：コピー連打癖がある人は多いので、代替ホットキー併設、3回コピー発火オプション、発火時通知の3点が現実的。
	•	自動貼り付けは危険：入力先誤り事故が起きやすい。初期OFFが合理的。
	•	外部送信の機密性：除外アプリ + 禁止パターン + 履歴OFFデフォルトがないと業務で破綻しやすい。
	•	AIの“それっぽい嘘”：翻訳は比較的安全だが、要約/意訳は情報の欠落・追加が起きうる。systemで「原文にない情報を足さない」を強制する前提が必要。

⸻

結論

Phase 1では「ccで即送信→結果を即クリップボード化」を核にしつつ、誤爆・機密漏えい・自動貼り付け事故の3点を設計で封じるのが最優先です。加えて、Provider差し替え前提の内部I/Fを固定しておけば、将来のローカルAI切替や、DB参照で仕様書ドラフト生成（裏で継続更新する機能）も、UI体験を崩さず段階的に拡張できます。